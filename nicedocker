#!/bin/bash

set -e

SERVICE_DIR=/services
[ -d $SERVICE_DIR ] || mkdir $SERVICE_DIR
CSP_FILE=/etc/.fp/csp.conf
REPOHOST=nicedocker.com
[ -d /opt/nicescale/support/etc ] || mkdir -p /opt/nicescale/support/etc

nicescale_env() {
  test -f $CSP_FILE
}

# supported command
usage() {
  echo -e "Usage: $0 command args ...

The $0 commands supported now are:
   run      run some type service in docker, args: type vsn name id
   ps       view all dockers mananged by nicescale
   login    login docker, execute command interactively, args: id
   exec     exec command once in docker non-interactively, args: id cmd
   start    start stopped docker container, args: id
   stop     stop running docker container, args: id
   restart  restart docker, equal stop && start, args: id
   rm       delete stopped docker container, no purge data, args: id
   service  operate service, args: id action, actions: {start|stop|reload|restart|status|destroy} 
"
}

error() {
  echo -ne "\e[0;31mError\e[m: " 1>&2
  echo $* 1>&2
  return 1
}
warn() {
  echo -ne "\e[0;33mWarn\e[m: " 1>&2
  echo $* 1>&2
  return 0
}
die() {
  echo -ne "\e[0;31mError\e[m: " 1>&2
  echo $* 1>&2
  exit 1
}
info() {
  echo -ne "\e[0;32mInfo\e[m: "
  echo $*
  return 0
}
get_repo() {
  local name
  local region
  if [ -f $CSP_FILE ]; then
    . $CSP_FILE
    echo $DOCKER_HOST
  else
    echo $REPOHOST
  fi
}

get_type_by_id() {
  sid=$1
  [ -e $SERVICE_DIR/$sid ] || error "serviceid $sid not exist"
  if [ -f $SERVICE_DIR/$sid/admin/service.ini ]; then
    . $SERVICE_DIR/$sid/admin/service.ini
    echo $SERVICE_TYPE
  else
    #error "cannot find file: $SERVICE_DIR/$sid/admin/service.ini"
    echo unknown
    exit 1
  fi
}

get_vsn_by_id() {
  sid=$1
  [ -d $SERVICE_DIR/$sid ] || error "serviceid $sid not exist"
  if [ -f $SERVICE_DIR/$sid/admin/service.ini ]; then
    . $SERVICE_DIR/$sid/admin/service.ini
    echo $SERVICE_VERSION
  else
    echo unknown
    exit 1
    #error "cannot find file: $SERVICE_DIR/$sid/admin/service.ini"
  fi
}

get_name_by_id() {
  sid=$1
  [ -d $SERVICE_DIR/$sid ] || die "service $sid not exist."
  [ -f $SERVICE_DIR/$sid/admin/service.ini ] || die "no service.ini for service $sid, maybe deployed failed."
  cat $SERVICE_DIR/$sid/admin/service.ini|sed -n 's/SERVICE_NAME=\(.*\)/\1/p'
}

get_logdir() {
RUBY=/opt/nicescale/support/bin/ruby
logdir_ruby="
require 'fp/node'
begin
paths=FP::Vars.get_service_var('$serviceid', 'path_config', 'meta')
paths.each_pair { |k, v|
  if k == 'log'; puts v;return v; end
}
rescue
  puts ''
end
"
$RUBY -e "$logdir_ruby"
}

get_datadir() {
RUBY=/opt/nicescale/support/bin/ruby
datadir_ruby="
require 'fp/node'
begin
paths=FP::Vars.get_service_var('$serviceid', 'path_config', 'meta')
paths.each_pair { |k, v|
  if k == 'data'; puts v;return v; end
}
rescue
  puts ''
end
"
$RUBY -e "$datadir_ruby"
}

# servicetype servicevsn servicename serviceid
dprepare() {
  servicetype=$1
  servicevsn=$2
  servicename=$3
  serviceid=$4
  serviceinfo=$SERVICE_DIR/$serviceid/admin/service.ini
  def_service_log_dir=$SERVICE_DIR/$serviceid/log
  def_service_data_dir=$SERVICE_DIR/$serviceid/data

  if [ "x$servicetype" = "x" -o "x$servicevsn" = "x" -o "x$servicename" = "x" -o "x$serviceid" = "x" ]; then
    usage
    exit 1
  fi

  if nicescale_env; then
    service_log_dir=`get_logdir`
    service_data_dir=`get_datadir`
  fi

  if [ -f $serviceinfo ]; then
    warn "serviceid $serviceid exists! checking status ..."
    . $serviceinfo
    if [ "$DEPLOY_STATUS" = "ok" ]; then
      echo -e "service $serviceid status: OK, neednot be deployed again."
      echo -e "if you want deploy it anyway, please run nicedocker stop $serviceid && nicedocker rm $serviceid." 
      exit 0
    fi
    echo "service $serviceid status: no, trying to remove this service and prepare it again ..."
    dkill $serviceid 2>/dev/null
    service_destroy $serviceid
  fi

  mkdir -p $SERVICE_DIR/$serviceid
  cd $SERVICE_DIR/$serviceid
  [ -d $SERVICE_DIR/$serviceid/admin ] || mkdir -p $SERVICE_DIR/$serviceid/admin

  repohost=`get_repo`
  image=$repohost:5000/nicescale/$servicetype:$servicevsn

  tmp_container="tmp-container"-`date +%s`
  docker run --rm --name $tmp_container $image sleep 300 &

  count=0
  while [ $count -lt 25 ]; do
    sleep 0.2
    count=$(( count+1 ))
    if docker top $tmp_container > /dev/null 2>&1; then break
    else true; fi
  done

  docker cp $tmp_container:/opt/nicedocker/path.ini admin/
  . admin/path.ini

  if [ -n "$conf" ]; then
    docker cp $tmp_container:$conf ./
    mv `basename $conf` conf
  fi

  if [ -n "$log" ]; then
    if [ "$service_log_dir" = $def_service_log_dir ] || [ -z "$service_log_dir" ]; then
      docker cp $tmp_container:$log ./ && mv `basename $log` log
    else
      log_basename=`basename $service_log_dir`
      [ -d $service_log_dir ] && rmdir $service_log_dir 2>/dev/null
      log_dirname=`dirname $service_log_dir`
      docker cp $tmp_container:$log $log_dirname/ &&
      [ "$log_basename" != `basename $log` ] && mv $log_dirname/`basename $log` $log_dirname/$log_basename
      ln -s $service_log_dir /services/$serviceid/log
    fi
  fi

  if [ -n "$data" ]; then
    if [ "$service_data_dir" = $def_service_data_dir ] || [ -z "$service_data_dir" ]; then
      docker cp $tmp_container:$data ./ && mv `basename $data` data
    else
      data_basename=`basename $service_data_dir`
      [ -d $service_data_dir ] && rmdir $service_data_dir 2>/dev/null
      data_dirname=`dirname $service_data_dir`
      docker cp $tmp_container:$data $data_dirname/ &&
      [ "$data_basename" != `basename $data` ] && mv $data_dirname/`basename $data` $data_dirname/$data_basename
      ln -s $service_data_dir /services/$serviceid/data
    fi
  fi

  docker cp $tmp_container:/opt/nicedocker/scripts ./ 2>/dev/null || true
  docker kill $tmp_container > /dev/null

  > $serviceinfo
  echo -e "SERVICE_TYPE=$servicetype\nSERVICE_VERSION=$servicevsn" >> $serviceinfo
  echo -e "SERVICE_NAME=$servicename\nSERVICE_ID=$serviceid" >> $serviceinfo
  echo "finished preparing for service $serviceid"
}

service_exist() {
  sid=$1
  [ -d $SERVICE_DIR/$sid ] && docker ps --all|grep -q -w $sid && return 0
  return 1
}

dcreate() {
  servicetype=$1
  servicevsn=$2
  servicename=$3
  serviceid=$4
  serviceinfo=$SERVICE_DIR/$serviceid/admin/service.ini

  if [ "x$servicetype" = "x" -o "x$servicevsn" = "x" -o "x$servicename" = "x" -o "x$serviceid" = "x" ]; then
    usage
    exit 1
  fi

  [ -d $SERVICE_DIR/$serviceid ] || die "no serviceid directory:$SERVICE_DIR/$serviceid, forget prepare?"
  #is_running $serviceid && warn "service $serviceid is running." && return 0
  service_exist $serviceid && warn "service $serviceid already exist." && return 0

  . $SERVICE_DIR/$serviceid/admin/path.ini
  volume="-v /dev/log:/dev/log"
  [ ! -z "$conf" ] && volume="-v $SERVICE_DIR/$serviceid/conf:$conf "$volume
  [ ! -z "$log" ] && volume="-v $SERVICE_DIR/$serviceid/log:$log "$volume
  [ ! -z "$data" ] && volume="-v $SERVICE_DIR/$serviceid/data:$data "$volume

  envvar=
  nicescale_env && envvar="-e NICESCALE=1"
  [ ! -z "$conf" ] && envvar="-e CONF_DIR=$conf "$envvar
  [ ! -z "$log" ] && envvar="-e LOG_DIR=$log "$envvar
  [ ! -z "$data" ] && envvar="-e DATA_DIR=$data "$envvar

  repohost=`get_repo`
  #prj_id=abcdefg
  #if docker pull $repohost:5000/$prj_id/$serviceid:latest; then
  #  echo
    #image=$repohost:5000/$prj_id/$serviceid:latest
  #else
    image=$repohost:5000/nicescale/$servicetype:$servicevsn
  #fi

  get_process_mgt
  if [ "$process_mgt" = "initctl" ]; then
cat <<EOF > /etc/init/docker-${sid}.conf
description "Docker Service $sid"

start on started docker
stop on stopping docker

respawn
respawn limit 20 5

script
  count=0
  while [ \$count -lt 100 ]; do
    sleep 0.2
    count=\$((count+1))
    docker ps > /dev/null 2>&1 || continue
    break
  done
  [ \$count -eq 100 ] && echo "no docker server running." && exit 1

  docker start $sid 2>/dev/null ||
  docker run -d --name $serviceid --net=host $volume $envvar $image

  count=0
  while [ \$count -lt 100 ]; do
    sleep 0.1
    count=\$((count+1))
    docker top $serviceid > /dev/null 2>&1 || continue
    break
  done
  [ \$count -eq 100 ] && echo "service $serviceid run failed." && exit 1

  /opt/nicescale/support/bin/cfagent prjenv-add $sid
  docker wait $sid
end script

post-stop script
  /opt/nicescale/support/bin/cfagent prjenv-del $sid
  if [ -x $SERVICE_DIR/$sid/scripts/stop.sh ]; then $SERVICE_DIR/$sid/scripts/stop.sh
  else docker stop $sid; fi
end script
EOF

  $process_mgt status docker-$sid|grep -q running ||
  $process_mgt start docker-$sid

  elif [ "$process_mgt" = "systemctl" ]; then
    echo preparing to support systemd
  else
    echo "unsupported process manage tool."
  fi

  es=$?
  if [ $es -eq 0 ]; then
    grep -q 'DEPLOY_STATUS' $serviceinfo ||
    echo "DEPLOY_STATUS=ok" >> $serviceinfo
  else
    grep -q 'DEPLOY_STATUS' $serviceinfo ||
    echo "DEPLOY_STATUS=no" >> $serviceinfo
    exit $es
  fi
  if [ -x $SERVICE_DIR/$serviceid/scripts/create.sh ] && nicescale_env; then
    $SERVICE_DIR/$serviceid/scripts/create.sh
    [ $? -ne 0 ] && echo "execute create.sh failed after launching container." && 
    sed -i 's/DEPLOY_STATUS=ok/DEPLOY_STATUS=no/' $serviceinfo && exit 1
  fi
  exit 0
}

dservice() {
  sid=$1
  action=$2
  if [ "x$sid" = "x" -o "x$action" = "x" ]; then
    usage
    exit 1
  fi
  [ -e $SERVICE_DIR/$sid ] || die "serviceid $1 not exist"

  get_process_mgt

  case "$action" in
  start)
    output=`$process_mgt status docker-$sid`
    if echo $output|grep -q -v running; then
      $process_mgt start docker-$sid
    else
      echo $output
    fi
    ;;
  stop)
    output=`$process_mgt status docker-$sid`
    if echo $output|grep -q running; then
      $process_mgt stop docker-$sid
    else
      echo $output
    fi
    ;;
  reload)
    output=`$process_mgt status docker-$sid`
    if echo $output|grep -q -v running; then
      $process_mgt start docker-$sid
    elif [ -x $SERVICE_DIR/$sid/scripts/reload.sh ]; then
      $SERVICE_DIR/$sid/scripts/reload.sh
    else
      $process_mgt restart docker-$sid
    fi
    ;;
  restart)
    output=`$process_mgt status docker-$sid`
    if echo $output|grep -q running; then
      $process_mgt restart docker-$sid
    else
      $process_mgt start docker-$sid
    fi
    ;;
  status)
    if [ -x $SERVICE_DIR/$sid/scripts/status.sh ]; then $SERVICE_DIR/$sid/scripts/status.sh
    elif docker top $sid > /dev/null 2>&1; then echo Service $sid is running.
    else echo Service $sid is stopped. && exit 1
    fi
    ;;
  destroy)
    service_destroy $sid
    ;;
  *)
    echo "Usage: $0 service $sid {start|stop|restart|reload|status|destroy}" >&2
    exit 1
    ;;
  esac
}

dstart() {
  sid=$1
  if [ "x$sid" = "x" ]; then
    usage
    exit 1
  fi

  [ -e $SERVICE_DIR/$sid ] || die "service $1 not exist"

  docker start $sid
}

dstop() {
  sid=$1
  if [ "x$sid" = "x" ]; then
    usage
    exit 1
  fi

  [ -e $SERVICE_DIR/$sid ] || die "serviceid $1 not exist"
  is_running $sid || warn "service $sid status is stopped, should not be stopped again."
  docker ps | grep -wq $sid || exit 0
  docker stop $sid 
}

dkill() {
  sid=$1
  if [ "x$sid" = "x" ]; then
    usage
    exit 1
  fi
  [ -e $SERVICE_DIR/$sid ] || die "service $1 not exist"
  if is_running $sid; then
    docker kill $sid
  else
    warn "service $sid status is stopped, should not be killed again."
  fi
}

drestart() {
  sid=$1
  dstop $sid
  sleep 0.2
  dstart $sid
}

is_running() {
  sid=$1
  if docker ps|grep -q -w " $sid"; then
    return 0
  fi
  return 1
}

drm() {
  sid=$1
  if [ "x$sid" = "x" ]; then
    usage
    exit 1
  fi

  docker rm $sid 
}

service_destroy() {
  sid=$1

  [ -e $SERVICE_DIR/$sid ] || die "service $sid not exists."

  is_running $sid && die "service $sid running, cannot remove"

  if [ -f /etc/init/docker-$sid.conf ]; then
    initctl stop -n docker-$sid 2>/dev/null || true
    rm -f /etc/init/docker-$sid.conf
  else
    true
  fi

  if ! docker rm $sid > /dev/null 2>&1; then
    sleep 2
    docker rm $sid >/dev/null 2>&1 || true
  else
    true
  fi

  cd $SERVICE_DIR/$sid
  if [ -L log ]; then
    logdir=`ls -l log|sed 's/^l.*-> \(.*\)/\1/'`
    [ -n "$logdir" -a "$logdir" != "/" -a "$logdir" != "/services" ] &&
    /bin/rm -fr $logdir
  fi
  if [ -L data ]; then
    datadir=`ls -l data|sed 's/^l.*-> \(.*\)/\1/'`
    [ -n "$datadir" -a "$datadir" != "/" -a "$datadir" != "/services" ] &&
    /bin/rm -fr $datadir
  fi
  cd /
  [ -z "$sid" ] || /bin/rm -fr $SERVICE_DIR/$sid
  echo service $sid removed! 
}

dlogin() {
  sid=$1
  if [ -z "$sid" ]; then
    usage
    exit 1
  fi
  is_running $sid || die "service $sid no run."
  sname=`get_name_by_id $sid`
  dexec $sid sh -c "/bin/echo -e 'PS1=\"root@$sname:\w# \"\nalias ls=\"ls --color=auto\"\nalias ll=\"ls -alF\"\nalias grep=\"grep --color=auto\"' > /opt/nicedocker/.bash.rcfile"
  dexec $sid bash --rcfile /opt/nicedocker/.bash.rcfile
}

dexec() {
  sid=$1
  if [ -z "$sid" ]; then
    usage
    exit 1
  fi
  is_running $sid || die "service $sid no run."
  PID=`docker top $sid|awk '{print $2}'|head -2|tail -1`
  [ -e /usr/local/bin/nsexec ] || die "no nsexec command."

  count=$(($# + 1 ))
  args=
  while [ $(( count-- )) -gt 2 ]; do
    args="\"\$$count\" $args"
  done

  eval "/usr/local/bin/nsexec $PID $args"
}

# this  is used for commit image after installed modules to filesystem
dreimage() {
  sid=$1
  tag=`date +%Y%m%d%H%M`
  repohost=`get_repo`
  docker commit $sid $repohost:5000/$prj_id/$sid:$tag
  docker push $repohost:5000/$prj_id/$sid:$tag
  docker tag $repohost:5000/$prj_id/$sid:$tag $repohost:5000/$prj_id/$sid:latest
  docker push $repohost:5000/$prj_id/$sid:latest
}

dsearch() {
  search=$1
  repohost=`get_repo`
  curl http://$repohost:5000/search?$search
}

dimages() {
  repohost=`get_repo`
  docker images|grep "$repohost"
}
dpull() {
  docker pull $1
}
dpush() {
  docker push $1
}

dps() {
  #tabs -8
  echo -e "sid\t\t\t  sname\t\tsip\t\tstype\t\trunning"
  cd $SERVICE_DIR
  for sid in `ls -l|grep -v admin|grep ^d|awk '{print $9}'`; do
    running=no
    if docker ps|grep -q -w " $sid"; then
      running=yes
    elif docker ps --all|grep -q -w " $sid"; then
      running=no
    else
      running=deleted
    fi
    ipaddr=`docker inspect $sid 2>/dev/null|grep IPAddress|sed -n "s/.*\"\([0-9].*[0-9]\)\".*/\1/p"`
    [ -z $ipaddr ] && ipaddr='N/A\t'
    echo -e "$sid  `get_name_by_id $sid`\t$ipaddr\t`get_type_by_id $sid`:`get_vsn_by_id $sid`\t$running"
  done
}

rpm_or_dpkg() {
  if [ -e /etc/apt/sources.list ]; then
    echo dpkg
  elif which rpm > /dev/null; then
    echo rpm
  else
    echo unsupported
  fi
}
get_process_mgt() {
  pack=`rpm_or_dpkg`
  process_mgt=
  if [ "$pack" = "rpm" ]; then
    if rpm -qf /sbin/init|grep -q -i systemd; then process_mgt=systemctl
    else process_mgt=initctl
    fi
  elif [ "$pack" = "dpkg" ]; then
    if dpkg -S /sbin/init|grep -q -i systemd; then process_mgt=systemctl
    else process_mgt=initctl
    fi
  else
    echo unknown
  fi
}
dupstart() {
  sid=$1
  cat <<EOF > /etc/init/docker-${sid}.conf
description "Docker Service $sid"

start on started docker
stop on stopping docker

respawn limit 20 5

script
  /usr/local/bin/nicedocker start $sid &&
  /opt/nicescale/support/bin/cfagent prjenv-add $sid
end script

pre-stop script
  /opt/nicescale/support/bin/cfagent prjenv-del $sid &&
  /usr/local/bin/nicedocker service $sid stop
end script
EOF
}

service_register() {
  PRO_MGT=`get_process_mgt`
  if [ "$PRO_MGT" = "upstart" ]; then
    dupstart $1
  elif [ "$PRO_MGT" = "systemd" ]; then
    echo
  else
    echo "unsupported process manage tool."
  fi
}

if [ "x$1" = "xrun" ]; then
  dprepare $2 $3 "$4" $5 
  dcreate $2 $3 "$4" $5
elif [ "x$1" = "xprepare" ]; then
  dprepare $2 $3 "$4" $5
elif [ "x$1" = "xcreate" ]; then
  dcreate $2 $3 "$4" $5
elif [ "x$1" = "xstart" ]; then
  dstart $2
elif [ "x$1" = "xstop" ]; then
  dstop $2
elif [ "x$1" = "xrestart" ]; then
  drestart $2
elif [ "x$1" = "xservice" ]; then
  dservice $2 $3
elif [ "x$1" = "xrm" ]; then
  drm $2 $3
elif [ "x$1" = "xlogin" ]; then
  dlogin $2
elif [ "x$1" = "xexec" ]; then
  count=$(($# + 1 ))
  args=
  while [ $(( count-- )) -gt 2 ]; do
    args="\"\$${count}\" $args"
  done
  eval "dexec $args"
elif [ "x$1" = "xcommit" ]; then
  dreimage $2
elif [ "x$1" = "xsearch" ]; then
  dsearch
elif [ "x$1" = "ximages" ]; then
  dimages
elif [ "x$1" = "xpull" ]; then
  dpull $2
elif [ "x$1" = "xpush" ]; then
  dpush $2
elif [ "x$1" = "xps" ]; then
  dps
elif [ "x$1" = "xkill" ]; then
  dkill $2
else
  [ ! -z $1 ] && error "Invalid command $1!"
  usage
fi

